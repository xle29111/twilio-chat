name: PR checks

on:
  pull_request:
    branches:
      - main
      - rt
      - develop

jobs:
  pr-checks:
    name: PR Checks
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Step 1: Check if the branch is up-to-date
      - name: Check if feature branch is up-to-date with base branch
        id: up_to_date
        continue-on-error: true
        run: |
          BASE_BRANCH=${{ github.base_ref }}
          FEATURE_BRANCH=${{ github.head_ref }}

          echo "Base branch is: origin/$BASE_BRANCH"
          echo "Feature branch is: origin/$FEATURE_BRANCH"

          git fetch origin $BASE_BRANCH
          git fetch origin $FEATURE_BRANCH

          if git merge-base --is-ancestor origin/$BASE_BRANCH origin/$FEATURE_BRANCH; then
            echo "✅ The feature branch is up-to-date with origin/$BASE_BRANCH. Merge is allowed."
          else
            echo "❌ The feature branch is not up-to-date with origin/$BASE_BRANCH. You need to rebase or merge first."
            exit 1
          fi

      # Step 2: Validate version
      - name: Validate version
        continue-on-error: true
        run: |
          BASE_BRANCH=${{ github.base_ref }}
          git fetch origin $BASE_BRANCH
          git checkout $BASE_BRANCH
          BASE_VERSION=$(node -p "require('./package.json').version")
          echo "Base version (main): $BASE_VERSION"

          git checkout ${{ github.head_ref }}
          NEW_VERSION=$(node -p "require('./package.json').version")
          echo "New version (PR): $NEW_VERSION"

          IFS='.' read -ra CURRENT <<< "$BASE_VERSION"
          IFS='.' read -ra NEW <<< "$NEW_VERSION"

          if [ ${#NEW[@]} -ne 3 ]; then
            echo "::error::Version must be in format X.Y.Z (e.g., 1.2.3)"
            exit 1
          fi

          is_valid=false

          if [ ${NEW[0]} -gt ${CURRENT[0]} ]; then
            is_valid=true
          elif [ ${NEW[0]} -eq ${CURRENT[0]} ]; then
            if [ ${NEW[1]} -gt ${CURRENT[1]} ]; then
              is_valid=true
            elif [ ${NEW[1]} -eq ${CURRENT[1]} ]; then
              if [ ${NEW[2]} -gt ${CURRENT[2]} ]; then
                is_valid=true
              fi
            fi
          fi

          if [ "$is_valid" = true ]; then
            echo "✅ Version $NEW_VERSION is valid (greater than $BASE_VERSION)"
          else
            echo "::error::Version $NEW_VERSION must be greater than $BASE_VERSION"
            exit 1
          fi

      # Step 4: Lint JSON
      - name: JSON Lint
        continue-on-error: true
        run: |
          if [ ! -f "flows_to_deploy.json" ]; then
            echo "::error::File flows_to_deploy.json not found"
            exit 1
          fi

          if ! jq empty flows_to_deploy.json 2> jq_error.log; then
            echo "::error::Invalid JSON syntax"
            exit 1
          fi

          DUPLICATES=$(jq -r '.[].application' flows_to_deploy.json | sort | uniq -d)
          if [ -n "$DUPLICATES" ]; then
            echo "::error::Duplicate application names found"
            exit 1
          fi

          echo "✅ flows_to_deploy.json validation passed."

  validate-flows-deploy:
    name: Validate flows_to_deploy.json traceability
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository with full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate flows_to_deploy.json traceability
        run: |
          set -e

          BASE_BRANCH=${{ github.base_ref }}
          FEATURE_BRANCH=${{ github.head_ref }}

          echo "Fetching base branch $BASE_BRANCH and feature branch $FEATURE_BRANCH"
          git fetch origin $BASE_BRANCH
          git fetch origin $FEATURE_BRANCH

          # Checkout base branch and save the base flows_to_deploy.json
          git checkout origin/$BASE_BRANCH -- flows_to_deploy.json
          BASE_FILE="flows_to_deploy_base.json"
          cp flows_to_deploy.json $BASE_FILE

          # Checkout feature branch and save the new flows_to_deploy.json
          git checkout origin/$FEATURE_BRANCH -- flows_to_deploy.json
          FEATURE_FILE="flows_to_deploy_feature.json"
          cp flows_to_deploy.json $FEATURE_FILE

          echo "Comparing deploy flags between base and feature branches..."

          APPS_BASE_TRUE=$(jq -r '.[] | select(.deploy == true) | .application' $BASE_FILE)

          errors=0

          for app in $APPS_BASE_TRUE; do
            deploy_feature=$(jq -r --arg app "$app" '.[] | select(.application == $app) | .deploy' $FEATURE_FILE || echo "missing")

            if [ "$deploy_feature" != "true" ]; then
              echo "::error::Application \"$app\" was deploy:true in base branch but is now deploy:false or missing in feature branch."
              errors=$((errors + 1))
            fi
          done

          if [ $errors -ne 0 ]; then
            echo "❌ Validation failed: deploy flags that were true in base branch cannot be reverted to false or removed."
            exit 1
          fi

          echo "✅ flows_to_deploy.json preserves deploy:true flags from base branch."
