name: PR checks

on:
  pull_request:
    branches:
      - main
      - rt

jobs:
  pr-checks:
    name: PR Checks
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Step 1: Check if the branch is up-to-date
      - name: Check if feature branch is up-to-date with base branch
        id: up_to_date
        continue-on-error: true
        run: |
          BASE_BRANCH=${{ github.base_ref }}
          FEATURE_BRANCH=${{ github.head_ref }}

          echo "Base branch is: origin/$BASE_BRANCH"
          echo "Feature branch is: origin/$FEATURE_BRANCH"

          git fetch origin $BASE_BRANCH
          git fetch origin $FEATURE_BRANCH

          if git merge-base --is-ancestor origin/$BASE_BRANCH origin/$FEATURE_BRANCH; then
            echo "‚úÖ The feature branch is up-to-date with origin/$BASE_BRANCH. Merge is allowed."
            echo "UP_TO_DATE_RESULT=success" >> $GITHUB_ENV
          else
            echo "‚ùå The feature branch is not up-to-date with origin/$BASE_BRANCH. You need to rebase or merge first."
            echo "UP_TO_DATE_RESULT=failure" >> $GITHUB_ENV
          fi

      # Step 2: Validate version
      - name: Validate version
        id: validate_version
        continue-on-error: true
        run: |
          BASE_BRANCH=${{ github.base_ref }}
          git fetch origin $BASE_BRANCH
          git checkout $BASE_BRANCH
          BASE_VERSION=$(node -p "require('./package.json').version")
          echo "Base version (main): $BASE_VERSION"

          git checkout ${{ github.head_ref }}
          NEW_VERSION=$(node -p "require('./package.json').version")
          echo "New version (PR): $NEW_VERSION"

          IFS='.' read -ra CURRENT <<< "$BASE_VERSION"
          IFS='.' read -ra NEW <<< "$NEW_VERSION"

          if [ ${#NEW[@]} -ne 3 ]; then
            echo "::error::Version must be in format X.Y.Z (e.g., 1.2.3)"
            echo "VALIDATE_VERSION_RESULT=failure" >> $GITHUB_ENV
            exit 1
          fi

          is_valid=false

          if [ ${NEW[0]} -gt ${CURRENT[0]} ]; then
            is_valid=true
          elif [ ${NEW[0]} -eq ${CURRENT[0]} ]; then
            if [ ${NEW[1]} -gt ${CURRENT[1]} ]; then
              is_valid=true
            elif [ ${NEW[1]} -eq ${CURRENT[1]} ]; then
              if [ ${NEW[2]} -gt ${CURRENT[2]} ]; then
                is_valid=true
              fi
            fi
          fi

          if [ "$is_valid" = true ]; then
            echo "‚úÖ Version $NEW_VERSION is valid (greater than $BASE_VERSION)"
            echo "VALIDATE_VERSION_RESULT=success" >> $GITHUB_ENV
          else
            echo "::error::Version $NEW_VERSION must be greater than $BASE_VERSION"
            echo "VALIDATE_VERSION_RESULT=failure" >> $GITHUB_ENV
            exit 1
          fi

      # Step 3: Validate flows_to_deploy.json
      - name: Validate flows_to_deploy.json
        id: validate_flows
        continue-on-error: true
        run: |
          BASE_BRANCH=${{ github.base_ref }}
          git fetch origin $BASE_BRANCH
          git checkout $BASE_BRANCH

          git checkout ${{ github.head_ref }}
          CHANGED_FILES=$(git diff --name-only origin/$BASE_BRANCH...origin/${{ github.head_ref }} | grep '^my-project/resources/' || true)

          if [ -z "$CHANGED_FILES" ]; then
            echo "No changes detected in my-project/resources/"
            echo "VALIDATE_FLOWS_RESULT=success" >> $GITHUB_ENV
            exit 0
          fi

          MODIFIED_FOLDERS=$(echo "$CHANGED_FILES" | cut -d'/' -f3 | sort -u)
          echo "Modified folders:"
          echo "$MODIFIED_FOLDERS"

          echo "$MODIFIED_FOLDERS" | while IFS= read -r folder; do
            if [ -z "$folder" ]; then continue; fi
            echo "üîç Checking folder: '$folder'"
            jq -e --arg folder "$folder" '.[] | select(.application == $folder and .deploy == true)' flows_to_deploy.json > /dev/null || echo "$folder" >> invalid_folders.txt
          done

          if [ -f invalid_folders.txt ]; then
            echo "‚ùå The following folders are not enabled for deploy:"
            cat invalid_folders.txt
            echo "VALIDATE_FLOWS_RESULT=failure" >> $GITHUB_ENV
            exit 1
          else
            echo "‚úÖ All modified folders are enabled for deploy."
            echo "VALIDATE_FLOWS_RESULT=success" >> $GITHUB_ENV
          fi

      # Step 4: Lint JSON
      - name: JSON Lint
        id: json_lint
        continue-on-error: true
        run: |
          if [ ! -f "flows_to_deploy.json" ]; then
            echo "::error::File flows_to_deploy.json not found"
            echo "JSON_LINT_RESULT=failure" >> $GITHUB_ENV
            exit 1
          fi

          if ! jq empty flows_to_deploy.json 2> jq_error.log; then
            echo "::error::Invalid JSON syntax"
            echo "JSON_LINT_RESULT=failure" >> $GITHUB_ENV
            exit 1
          fi

          DUPLICATES=$(jq -r '.[].application' flows_to_deploy.json | sort | uniq -d)
          if [ -n "$DUPLICATES" ]; then
            echo "::error::Duplicate application names found"
            echo "JSON_LINT_RESULT=failure" >> $GITHUB_ENV
            exit 1
          fi

          echo "‚úÖ flows_to_deploy.json validation passed."
          echo "JSON_LINT_RESULT=success" >> $GITHUB_ENV

      # Final Step: Global Validation
      - name: Final Validation
        run: |
          if [ "$UP_TO_DATE_RESULT" != "success" ] || [ "$VALIDATE_VERSION_RESULT" != "success" ] || [ "$VALIDATE_FLOWS_RESULT" != "success" ] || [ "$JSON_LINT_RESULT" != "success" ]; then
            echo "‚ùå One or more checks failed."
            exit 1
          else
            echo "‚úÖ All checks passed successfully."
          fi