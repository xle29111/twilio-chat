name: PR checks

on:
  pull_request:
    branches:
      - main
      - rt

jobs:
  up-to-date:
    name: up-to-date
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if feature branch is up-to-date with base branch
        run: |
          BASE_BRANCH=${{ github.base_ref }}
          FEATURE_BRANCH=${{ github.head_ref }}

          echo "Base branch is: origin/$BASE_BRANCH"
          echo "Feature branch is: origin/$FEATURE_BRANCH"

          git fetch origin $BASE_BRANCH
          git fetch origin $FEATURE_BRANCH

          if git merge-base --is-ancestor origin/$BASE_BRANCH origin/$FEATURE_BRANCH; then
            echo "‚úÖ The feature branch is up-to-date with origin/$BASE_BRANCH. Merge is allowed."
          else
            echo "‚ùå The feature branch is not up-to-date with origin/$BASE_BRANCH. You need to rebase or merge first."
            exit 1
          fi

  version-validation:
    name: version-validation
    runs-on: ubuntu-latest
    needs: up-to-date

    steps:
      - name: Checkout base branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.base_ref }}

      - name: Extract base version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          echo "BASE_VERSION=$VERSION" >> $GITHUB_ENV

      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}

      - name: Validate version
        run: |
          echo "Base version (main): $BASE_VERSION"
          NEW_VERSION=$(node -p "require('./package.json').version")
          echo "New version (PR): $NEW_VERSION"

          IFS='.' read -ra CURRENT <<< "$BASE_VERSION"
          IFS='.' read -ra NEW <<< "$NEW_VERSION"

          if [ ${#NEW[@]} -ne 3 ]; then
            echo "::error::Version must be in format X.Y.Z (e.g., 1.2.3)"
            exit 1
          fi

          is_valid=false

          if [ ${NEW[0]} -gt ${CURRENT[0]} ]; then
            is_valid=true
          elif [ ${NEW[0]} -eq ${CURRENT[0]} ]; then
            if [ ${NEW[1]} -gt ${CURRENT[1]} ]; then
              is_valid=true
            elif [ ${NEW[1]} -eq ${CURRENT[1]} ]; then
              if [ ${NEW[2]} -gt ${CURRENT[2]} ]; then
                is_valid=true
              fi
            fi
          fi

          if [ "$is_valid" = true ]; then
            echo "‚úÖ Version $NEW_VERSION is valid (greater than $BASE_VERSION)"
          else
            echo "::error::Version $NEW_VERSION must be greater than $BASE_VERSION"
            echo "Valid examples:"
            echo "Major bump: $((CURRENT[0]+1)).${CURRENT[1]}.${CURRENT[2]}"
            echo "Minor bump: ${CURRENT[0]}.$((CURRENT[1]+1)).${CURRENT[2]}"
            echo "Patch bump: ${CURRENT[0]}.${CURRENT[1]}.$((CURRENT[2]+1))"
            exit 1
          fi

  config-file:
    name: config-file
    runs-on: ubuntu-latest
    needs: up-to-date

    steps:
      - name: Checkout code from PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          fetch-depth: 0

      - name: Get modified folders from PR compared to base branch
        id: modified
        run: |
          echo "Detecting modified folders by comparing with the base branch..."
          BASE_BRANCH=${{ github.base_ref }}
          echo "Base branch is: origin/$BASE_BRANCH"
          echo "Source branch is: origin/${{ github.head_ref }}"

          git fetch origin $BASE_BRANCH
          git fetch origin ${{ github.head_ref }}

          CHANGED_FILES=$(git diff --name-only origin/$BASE_BRANCH...origin/${{ github.head_ref }} | grep '^my-project/resources/' || true)

          if [ -z "$CHANGED_FILES" ]; then
            echo "No changes detected in my-project/resources/"
            echo "MODIFIED_FOLDERS=" >> $GITHUB_ENV
          else
            MODIFIED_FOLDERS=$(while IFS= read -r file; do
              folder=$(echo "$file" | cut -d'/' -f3)
              echo "$folder"
            done <<< "$CHANGED_FILES" | sort -u)
            
            echo "Modified folders:"
            echo "$MODIFIED_FOLDERS"
            echo "MODIFIED_FOLDERS<<EOF" >> $GITHUB_ENV
            echo "$MODIFIED_FOLDERS" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
          fi

      - name: Get base branch flows_to_deploy.json
        id: get-base-flows
        run: |
          BASE_BRANCH=${{ github.base_ref }}
          git fetch origin $BASE_BRANCH
          git show origin/$BASE_BRANCH:flows_to_deploy.json > base_flows_to_deploy.json
          echo "BASE_FLOWS_FILE=base_flows_to_deploy.json" >> $GITHUB_ENV

      - name: Validate deployments
        run: |
          IFS=$'\n' read -r -d '' -a MODIFIED_ARRAY <<< "$MODIFIED_FOLDERS"
          
          ERROR_COUNT=0
          INVALID_APPS=()
          MISSING_DEPLOYMENTS=()

          jq -r '.[] | select(.deploy == true) | .application' flows_to_deploy.json | while read -r app; do
            echo "Checking deployment status for: $app"
            
            is_modified=false
            for modified_app in "${MODIFIED_ARRAY[@]}"; do
              if [ "$modified_app" == "$app" ]; then
                is_modified=true
                break
              fi
            done
            
            if [ "$is_modified" = true ]; then
              echo "‚úÖ $app: Valid deployment (application was modified)"
              continue
            fi
            
            BASE_DEPLOY=$(jq -r --arg app "$app" '.[] | select(.application == $app) | .deploy' base_flows_to_deploy.json)
            if [ "$BASE_DEPLOY" == "true" ]; then
              echo "‚úÖ $app: Valid deployment (already true in base branch)"
              continue
            fi
            
            echo "‚ùå $app: Invalid deployment - not modified and not true in base branch"
            INVALID_APPS+=("$app")
            ERROR_COUNT=$((ERROR_COUNT+1))
          done

          for folder in "${MODIFIED_ARRAY[@]}"; do
            [ -z "$folder" ] && continue
            
            PR_DEPLOY=$(jq -r --arg folder "$folder" '.[] | select(.application == $folder) | .deploy' flows_to_deploy.json)
            if [ "$PR_DEPLOY" != "true" ]; then
              echo "‚ùå \"$folder\": Modified but not set to true in flows_to_deploy.json"
              MISSING_DEPLOYMENTS+=("$folder")
              ERROR_COUNT=$((ERROR_COUNT+1))
            else
              echo "‚úÖ \"$folder\": Modified and properly set to true"
            fi
          done

          if [ $ERROR_COUNT -gt 0 ]; then
            echo "::error::Invalid configurations detected in flows_to_deploy.json"
            
            if [ ${#INVALID_APPS[@]} -gt 0 ]; then
              echo "The following applications cannot be set to 'true':"
              printf ' - "%s"\n' "${INVALID_APPS[@]}"
            fi
            
            if [ ${#MISSING_DEPLOYMENTS[@]} -gt 0 ]; then
              echo "The following modified applications must be set to 'true':"
              printf ' - "%s"\n' "${MISSING_DEPLOYMENTS[@]}"
            fi
            
            echo "Deployment Rules:"
            echo "1. Applications can only be set to 'true' if:"
            echo "   - They were modified in this PR, OR"
            echo "   - They were already 'true' in base branch"
            echo "2. All modified applications must be set to 'true'"
            exit 1
          else
            echo "‚úÖ All deployments are valid"
          fi

  json-lint:
    name: json-lint
    runs-on: ubuntu-latest
    needs: up-to-date

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install jq
        run: sudo apt-get install -y jq

      - name: Validate JSON syntax and duplicates
        run: |
          echo "üîç Validating flows_to_deploy.json..."
          echo "------------------------------------------------------"

          if [ ! -f "flows_to_deploy.json" ]; then
            echo "::error file=flows_to_deploy.json::File flows_to_deploy.json not found"
            exit 1
          fi

          if ! jq empty flows_to_deploy.json 2> jq_error.log; then
            echo "::error file=flows_to_deploy.json::Invalid JSON syntax"
            echo "‚ùå JSON Syntax Error Details:"
            cat jq_error.log

            ERROR_LINE=$(grep -oP 'line \K\d+' jq_error.log | head -1)
            if [ -n "$ERROR_LINE" ]; then
              echo "üõë Problematic area (around line $ERROR_LINE):"
              awk -v line="$ERROR_LINE" 'NR>=line-3 && NR<=line+3' flows_to_deploy.json
            fi
            exit 1
          fi

          DUPLICATES=$(jq -r '.[].application' flows_to_deploy.json | sort | uniq -d)
          if [ -n "$DUPLICATES" ]; then
            echo "::error file=flows_to_deploy.json::Duplicate application names found"
            echo "‚ùå Duplicate Application Names:"
            echo "$DUPLICATES"
            echo "------------------------------------------------------"
            echo "Duplicate entries:"
            jq -r 'group_by(.application)[] | select(length > 1) | .[] | "\(.application): deploy=\(.deploy)"' flows_to_deploy.json
            exit 1
          fi

          echo "------------------------------------------------------"
          echo "‚úÖ flows_to_deploy.json validation passed:"
          echo "- Valid JSON syntax"
          echo "- No duplicate application names"
          echo "Total applications configured: $(jq 'length' flows_to_deploy.json)"

  flows-traceability-check:
    name: flows traceability
    runs-on: ubuntu-latest
    needs: config-file

    steps:
      - name: Checkout base branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.base_ref }}
          path: base_branch

      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          path: pr_branch

      - name: Compare flows_to_deploy.json for traceability
        run: |
          echo "üîç Verifying flows_to_deploy.json traceability..."

          BASE_FILE="base_branch/flows_to_deploy.json"
          PR_FILE="pr_branch/flows_to_deploy.json"

          if [ ! -f "$BASE_FILE" ] || [ ! -f "$PR_FILE" ]; then
            echo "::error::Missing flows_to_deploy.json in one of the branches"
            exit 1
          fi

          jq -c '.[]' "$BASE_FILE" | while read -r base_entry; do
            app=$(echo "$base_entry" | jq -r '.application')
            base_deploy=$(echo "$base_entry" | jq -r '.deploy')

            pr_deploy=$(jq -r --arg app "$app" '.[] | select(.application == $app) | .deploy' "$PR_FILE")

            if [ "$base_deploy" = "true" ]; then
              if [ "$pr_deploy" != "true" ]; then
                echo "::error file=flows_to_deploy.json::Application '$app' was marked as deploy=true in base branch but is now missing or reverted to false."
                exit 1
              fi
            fi
          done

          echo "‚úÖ flows_to_deploy.json traceability check passed."
